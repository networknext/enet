	
    Actually create the client inside enet host.

	Fix enet early out on client "fail to connect" in client... (may require making it delay again...)

	Turn on enet debug prints.

	Connect the client to the server.

	Make sure we don't spinlock inside enet_host_service

	To get network next client and server connecting, need to setup customer keypair and dev environment...

	Hook up packet send for client and server.

	What does enet_protocol_handle_incoming_commands do? ---> processes received UDP packets, adds events to ENetEvent struct passed in.

	Who calls enet_protocol_receive_incoming_commands? ---> called once in service pump

	Does it call it once or multiple times? ----> one and done, but it's called in the service pump loop, so it's multiple.

	What fills in ENetEvent passed to receive incoming commands? -----> enet_protocol_handle_incoming_commands

	How is the ENetEvent used. Is it an output, or an input? ------> It's an output. Pass in the ENetEvent struct to enet_host_service and it gets filled with the received event.

	Can we just do the same processing in the callback instead? avoid buffering, just call it in and queue it up? ----> no. because of the design of enet, the pump for each event is performed via enet_host_service, which passes in the event -- looping until no more events are received.

	The strategy now must be to queue up received client and server packets from network next, and then pop off these queues inside enet_protocol_receive_incoming_commands in lieu of actually hitting the socket.

	Add network next received packet queue data structures inside ENetHost

	Work out allocation for new ENetInternalPacket struct being passed through linked list via pointer... what's the ENet strategy for allocators?

	Insert received packet data into the queue for client packet receive.

	Insert received packet data into the queue for server packet receive.

	Dequeue packets from receive queue and process them.

	Work out how to get address for server when the client receives a packet.

	Translate the client address to ENetAddress when the server receives a packet.

TODO

	------------

	Client should now be able to connect to server, but there seems to be something after receiving the packet, where it's not getting processed correctly into the client joining the game.

	Look into what is happening after receiving the packet from dequeue...

	When I disable network next integration, client connects, but also the packets sent and received are different.

	This indicates that something is broken with how I shunt packets through network next.

	I believe it's on the send side. The packets sent by the client look different on connect, with network next than they do without.

	What's the difference?

	It could also be something broken with the host service or protocol pump.

	------------

	Clean up:

		1. Fix up todos

		2. Pass in the network next data in host create

		3. Make sure no additional delay is added on packet receive due to ordering of calls (eg. don't get offset by one frame)

		4. Test with multiple clients connecting, to make sure no wires are crossed in server mux/demux of client packets.

	------------
